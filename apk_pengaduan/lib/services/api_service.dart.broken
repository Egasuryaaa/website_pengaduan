import 'package:dio/dio.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:get/get.dart' hide Response, FormData, MultipartFile;
import 'dart:io' show Platform;
import 'package:flutter/foundation.dart' show kIsWeb;

class ApiService {
  // Daftar alamat IP yang mungkin untuk server
  static final List<String> _possibleBaseUrls = [
    'http://10.0.2.2:8000/api',    // Android Emulator -> Host
    'http://localhost:8000/api',    // Local
    'http://127.0.0.1:8000/api',    // Local loopback
    //'http://192.168.1.x:8000/api'  // Update dengan IP jaringan lokal jika perlu
  ];
  
  static String _currentBaseUrl = _possibleBaseUrls[0];
  
  // Getter untuk base URL saat ini
  static String get baseUrl => _currentBaseUrl;
  
  // Method untuk mencoba URL alternatif jika yang utama gagal
  static String getNextBaseUrl() {
    final currentIndex = _possibleBaseUrls.indexOf(_currentBaseUrl);
    final nextIndex = (currentIndex + 1) % _possibleBaseUrls.length;
    _currentBaseUrl = _possibleBaseUrls[nextIndex];
    print('DEBUG: Switching to alternative baseUrl: $_currentBaseUrl');
    return _currentBaseUrl;
  }
  
  late Dio _dio;
  static const _storage = FlutterSecureStorage();
  
  static final ApiService _instance = ApiService._internal();
  factory ApiService() => _instance;
  
  // Deteksi platform untuk URL yang tepat
  static void _configurePlatformSpecificUrl() {
    if (kIsWeb) {
      // Saat dijalankan di browser, gunakan URL lokal
      _currentBaseUrl = 'http://localhost:8000/api';
      print('DEBUG: Running on web, setting baseUrl to: $_currentBaseUrl');
    } else {
      try {
        if (!Platform.isAndroid && !Platform.isIOS) {
          // Saat dijalankan di desktop
          _currentBaseUrl = 'http://localhost:8000/api';
          print('DEBUG: Running on desktop, setting baseUrl to: $_currentBaseUrl');
        }
      } catch (e) {
        // Ignore platform check errors on web
      }
    }
    // Android dan iOS tetap menggunakan _currentBaseUrl default
  }
  
  ApiService._internal() {
    _configurePlatformSpecificUrl();
    _initDio();
  }
  
  void _initDio() {
    print('DEBUG: Initializing ApiService with baseUrl: $baseUrl');
    
    _dio = Dio(BaseOptions(
      baseUrl: baseUrl,
      connectTimeout: const Duration(seconds: 30), // Meningkatkan timeout menjadi 30 detik
      receiveTimeout: const Duration(seconds: 30), // Meningkatkan timeout menjadi 30 detik
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      // Don't throw errors for status codes
      validateStatus: (status) => true,
    ));
    
    _dio.interceptors.add(InterceptorsWrapper(
      onRequest: (options, handler) async {
        final token = await _storage.read(key: 'auth_token');
        print('DEBUG: Sending request to ${options.baseUrl}${options.path}');
        print('DEBUG: Request data: ${options.data}');
        
        // Always add Accept header
        options.headers['Accept'] = 'application/json';
        
        // Public endpoints that don't need authentication
        final publicEndpoints = ['/login', '/register'];
        final isPublicEndpoint = publicEndpoints.any((endpoint) => options.path.contains(endpoint));
        
        if (token != null) {
          options.headers['Authorization'] = 'Bearer $token';
          print('DEBUG: Added auth token to request: Bearer $token');
        } else if (!isPublicEndpoint) {
          print('DEBUG: No auth token available for protected endpoint ${options.path}');
          
          // Skip immediate rejection for GET requests to allow graceful handling
          if (options.method != 'GET') {
            print('DEBUG: Non-GET request to protected endpoint without auth token');
            print('DEBUG: Redirecting to login for protected resource');
            
            // Schedule navigation after the current operation completes
            Future.microtask(() {
              Get.offAllNamed('/login');
            });
            
            return handler.reject(
              DioException(
                requestOptions: options,
                message: 'Authentication required',
              ),
            );
          }
        }
        
        print('DEBUG: Request headers: ${options.headers}');
        handler.next(options);
      },
      onResponse: (response, handler) {
        print('DEBUG: Response status: ${response.statusCode}');
        print('DEBUG: Response data: ${response.data}');
        
        // Handle 401 at the response level too
        if (response.statusCode == 401) {
          print('DEBUG: 401 Unauthorized response received');
          _handleAuthError();
        }
        
        handler.next(response);
      },
      onError: (error, handler) {
        print('DEBUG: Request error: ${error.message}');
        print('DEBUG: Response status: ${error.response?.statusCode}');
        print('DEBUG: Error response: ${error.response?.data}');
        
        if (error.response?.statusCode == 401) {
          // Token expired or invalid, handle auth error
          _handleAuthError();
        }
        
        handler.next(error);
      },
    ));
  }
  
  // Helper method to handle authentication errors
  void _handleAuthError() {
    print('DEBUG: Handling auth error - clearing token and redirecting to login');
    
    // Clear token
    _clearToken();
    
    // Schedule navigation after current operation completes
    Future.microtask(() {
      if (Get.currentRoute != '/login') {
        Get.offAllNamed('/login');
      }
    });
  }
  
  // Auth methods
  Future<Map<String, dynamic>> register(Map<String, dynamic> data) async {
    try {
      final response = await _dio.post('/register', data: data);
      return response.data;
    } catch (e) {
      rethrow;
    }
  }
  
  Future<Map<String, dynamic>> login(String email, String password) async {
    print('DEBUG: Logging in with email: $email');

    try {
      return await retryWithAlternativeBaseUrl(() async {
        try {
          // Use the correct endpoint as per the backend routes
          final response = await _dio.post('/login', data: {
            'email': email,
            'password': password,
          });
          
          print('DEBUG: Login response status: ${response.statusCode}');
          print('DEBUG: Login response data: ${response.data}');
          
          // Periksa format respons yang sesuai dengan Laravel Sanctum
      if (response.statusCode == 200) {
        if (response.data['token'] != null) {
          // Format langsung token
          print('DEBUG: Login successful, saving token');
          final token = response.data['token'];
          await _storage.write(key: 'auth_token', value: token);
          
          // Try to save user data if available
          if (response.data['user'] != null) {
            await _storage.write(key: 'user_data', value: response.data['user'].toString());
          }
          
          return {
            'success': true,
            'message': 'Login successful',
            'data': {
              'user': response.data['user'],
              'token': token
            }
          };
        } else if (response.data['data'] != null && response.data['data']['token'] != null) {
          // Format nested dengan data
          print('DEBUG: Login successful, saving token');
          final token = response.data['data']['token'];
          await _storage.write(key: 'auth_token', value: token);
          
          // Save user data if available
          if (response.data['data']['user'] != null) {
            await _storage.write(key: 'user_data', value: response.data['data']['user'].toString());
          }
          
          return {
            'success': true,
            'message': 'Login successful',
            'data': {
              'user': response.data['data']['user'],
              'token': token
            }
          };
        } else if (response.data['success'] == true) {
          // Respons sukses dari API kustom
          print('DEBUG: Login successful, saving token');
          final token = response.data['data']['token'];
          await _storage.write(key: 'auth_token', value: token);
          
          return response.data;  // Return respons langsung jika sudah sesuai format
        }
      }
      
      // Jika tidak ada kondisi di atas yang terpenuhi, maka login gagal
      String errorMessage = 'Login failed';
      
      if (response.data != null) {
        if (response.data['message'] != null) {
          errorMessage = response.data['message'];
        } else if (response.data['error'] != null) {
          errorMessage = response.data['error'];
        }
      }
      
      print('DEBUG: Login failed: $errorMessage');
      return {
        'success': false,
        'message': errorMessage,
      };
          }
        } catch (connectionError) {
          // Handle timeout or connection errors
          print('DEBUG: Connection error during login: $connectionError');
          
          if (connectionError is DioException) {
            if (connectionError.type == DioExceptionType.connectionTimeout) {
              throw connectionError; // Throw error to trigger retry with alternative URL
            } else if (connectionError.type == DioExceptionType.connectionError) {
              throw connectionError; // Throw error to trigger retry with alternative URL
            }
          }
          
          return {
            'success': false,
            'message': 'Gagal terhubung ke server: ${connectionError.toString()}',
          };
        }
      }) ?? {
        'success': false, 
        'message': 'Gagal terhubung ke semua server yang tersedia'
      };
    } catch (e) {
      print('DEBUG: Login exception: $e');
      return {
        'success': false,
        'message': 'Error saat login: $e',
      };
    }
  }
  
  Future<Map<String, dynamic>> logout() async {
    try {
      print('DEBUG: Logging out');
      
      // First check if we have a token
      final token = await getToken();
      if (token == null) {
        print('DEBUG: No token to logout with');
        return {'success': true, 'message': 'No active session'};
      }
      
      try {
        // Use the correct endpoint as per the backend routes
        final response = await _dio.post(
          '/logout',
          options: Options(
            headers: {
              'Authorization': 'Bearer $token',
              'Accept': 'application/json',
            },
          ),
        );
        print('DEBUG: Logout response: ${response.data}');
      } catch (apiError) {
        print('DEBUG: API error during logout: $apiError');
      }
      
      // Always clear the token
      await _clearToken();
      return {'success': true, 'message': 'Logged out successfully'};
    } catch (e) {
      print('DEBUG: Error during logout: $e');
      await _clearToken();
      return {'success': false, 'message': 'Error during logout: $e'};
    }
  }
  
  Future<Map<String, dynamic>> getProfile() async {
    try {
      print('DEBUG: Getting user profile');
      
      // Based on the Laravel API routes, the correct endpoint is '/user' or '/me'
      // First try '/user' which is the default Laravel Sanctum endpoint
      final response = await _dio.get('/user');
      
      print('DEBUG: Profile response from /user: ${response.data}');
      
      if (response.statusCode == 200) {
        print('DEBUG: Successfully retrieved user profile');
        
        // Handle both possible response formats from the API
        if (response.data != null) {
          return {
            'success': true,
            'data': response.data
          };
        } 
      } else {
        // If '/user' failed, try '/me' as alternative
        print('DEBUG: Failed with /user, trying /me endpoint');
        final altResponse = await _dio.get('/me');
        
        if (altResponse.statusCode == 200) {
          print('DEBUG: Successfully retrieved user profile from /me');
          return {
            'success': true,
            'data': altResponse.data
          };
        } else {
          print('DEBUG: Failed to get user profile from both endpoints');
          return {
            'success': false,
            'message': 'Failed to retrieve user profile'
          };
        }
      }
      
      print('DEBUG: Unknown error getting profile');
      return {
        'success': false,
        'message': 'Unknown error retrieving profile'
      };
    } catch (e) {
      print('DEBUG: Error getting profile: $e');
      return {
        'success': false,
        'message': 'Error getting profile: $e'
      };
    }
  }
  
  Future<Map<String, dynamic>> updateProfile(Map<String, dynamic> data) async {
    try {
      final response = await _dio.put('/profile', data: data);
      return response.data;
    } catch (e) {
      rethrow;
    }
  }
  
  Future<Map<String, dynamic>> changePassword(Map<String, dynamic> data) async {
    try {
      final response = await _dio.put('/change-password', data: data);
      return response.data;
    } catch (e) {
      rethrow;
    }
  }
  
  // Pengaduan methods
  Future<Map<String, dynamic>> getPengaduans() async {
    try {
      final response = await _dio.get('/pengaduan');
      return response.data;
    } catch (e) {
      rethrow;
    }
  }
  
  Future<Map<String, dynamic>> createPengaduan(Map<String, dynamic> data) async {
    try {
      // Check if we're authenticated before making the request
      final token = await getToken();
      print('DEBUG: Authentication token: ${token != null ? "Present" : "Missing"}');
      
      // Convert regular data to FormData
      FormData formData = FormData.fromMap(data);
      print('DEBUG: Sending data to API: $data');
      
      // Make the request with more detailed logging
      final response = await _dio.post(
        '/pengaduan',
        data: formData,
        options: Options(
          headers: {
            'Authorization': 'Bearer $token',
            'Accept': 'application/json',
          },
        ),
      );
      print('DEBUG: Response received: ${response.statusCode}');
      print('DEBUG: Response body: ${response.data}');
      
      return response.data;
    } catch (e) {
      if (e is DioException) {
        print('DEBUG: DioError: ${e.type}');
        print('DEBUG: Error message: ${e.message}');
        print('DEBUG: Response status: ${e.response?.statusCode}');
        print('DEBUG: Response data: ${e.response?.data}');
      } else {
        print('DEBUG: Unexpected error: $e');
      }
      rethrow;
    }
  }
  
  Future<Map<String, dynamic>> getPengaduanDetail(int id) async {
    try {
      final response = await _dio.get('/pengaduan/$id');
      return response.data;
    } catch (e) {
      rethrow;
    }
  }
  
  Future<Map<String, dynamic>> getStatistics() async {
    try {
      final response = await _dio.get('/pengaduan-statistics');
      return response.data;
    } catch (e) {
      rethrow;
    }
  }
  
  Future<Map<String, dynamic>> getKategori() async {
    try {
      final response = await _dio.get('/kategori');
      return response.data;
    } catch (e) {
      rethrow;
    }
  }
  
  // Helper methods
  Future<void> _clearToken() async {
    await _storage.delete(key: 'auth_token');
    await _storage.delete(key: 'user_data');
  }
  
  Future<String?> getToken() async {
    return await _storage.read(key: 'auth_token');
  }
  
  Future<bool> isLoggedIn() async {
    final token = await getToken();
    return token != null;
  }
  
  // Method untuk mencoba ulang dengan URL alternatif
  Future<T?> retryWithAlternativeBaseUrl<T>(Future<T> Function() apiCall) async {
    try {
      return await apiCall();
    } catch (e) {
      if (e is DioException && 
          (e.type == DioExceptionType.connectionTimeout ||
           e.type == DioExceptionType.connectionError)) {
        
        // Coba URL alternatif
        final newBaseUrl = ApiService.getNextBaseUrl();
        print('DEBUG: Retrying request with alternative base URL: $newBaseUrl');
        
        // Reinisialisasi Dio dengan URL baru
        _initDio();
        
        // Coba lagi dengan URL baru
        try {
          return await apiCall();
        } catch (retryError) {
          print('DEBUG: Retry failed: $retryError');
          rethrow;
        }
      } else {
        rethrow;
      }
    }
  }
}
